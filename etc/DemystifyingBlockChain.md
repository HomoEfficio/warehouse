# 가볍게 읽어 보는 블록 체인 이야기

2017년도 벌써 3/4가 지나갔다. 올 한해를 정리해보기엔 좀 이른 시간이지만, 그래도 이 시점에서 중간 점검 차 한 번 짚어보자. 소프트웨어 업계에서 올해 1~9월 사이에 일어났던 많은 일 들 가운데 가장 큰 이슈로 무엇을 꼽을 수 있을까?

여러 이슈가 있겠지만, 필자의 짧은 생각으로는 비트코인에 대한 관심의 폭증과 그에 따른 암호화 화폐 시장의 급등락과 ICO(Initial Coin Offering)를 꼽고 싶다.

%%% 비트코인 가격 차트 %%%

%%% 이더리움 가격 차트 %%%

%%% 주요 ICO 모금액 표 %%%

주변에서 몇 억을 벌었다는 이야기도 심심치 않게 들을 수 있고, 그에 못지 않게 많은 돈을 잃었다는 이야기도 들을 수 있다. 길게 볼 것 없이 올해 초 대비만 하더라도 변동성이 크긴 했지만 비트코인과 기타 암호화 화폐의 가격이 급등한 것은 사실이다. 그래서 거품이다, 17세기 유럽의 튤립 광풍과 다를게 없다 등의 이야기도 많이 들을 수 있다. 분명 가격으로만 보면 틀린 말이 아닐 수도 있다. 게다가 개발자가 아닌 일반인의 관점에서 보면 아무래도 기술적인 내용은 이해하기 어렵고, 가격 급등락에 의한 여러 에피소드는 이해하기 쉬울 테니, 가격에 대한 면이 부각되는 것은 어쩔 수 없는 일이기는 하다.

하지만 마이크로소프트웨어라는 이 잡지를 보고 있는 우리는 소프트웨어를 다루는 개발자들이다. 그리고 비트코인도 당연하지만 소프트웨어다. 그럼에도 불구하고, 우리나라에서는 개발자들마저 비트코인을 바라보는 관점이 일반인의 관점과 크게 다르지 않은 것 같다. 그래서 이번 기회에 개발자답게, 일반인들보다 조금 더 깊게 탐험해 보고, 어떤 의미를 가지고 있는지 알아보자.

## 비트코인과 블록 체인

제목은 블록 체인 이야기라고 써놓고, 서두에서는 비트코인 얘기만 했다. 비트코인과 블록 체인이 무엇인지 구별하는 것이 좋겠다는 의도에서 일부러 그렇게 기술했는데, 다음과 같이 구별할 수 있다.

>블록 체인은 비트코인의 바탕이 되는 '체계'이며,
>
>비트코인은 블록 체인을 '화폐'에 응용한 결과물이다.

**블록 체인이 바탕**이고, **비트코인은 블록 체인 바탕위에서 구현된 하나의 서비스 또는 상품**이라고 할 수 있다. 그래서 블록 체인은 비트코인 뿐아니라 다른 코인의 바탕이 될 수도 있고 실제로도 그렇다. 또한 블록 체인은 코인 뿐아니라 다른 서비스나 상품의 바탕이 될 수도 있다.

재미있는 것은 블록 체인이 비트코인의 바탕이 되는 체계이지만, 블록 체인이 만들어지고 비트코인이 만들어진 것이 아니라 비트코인을 만들기 위해 고민하던 중에 블록 체인이라는 기술이 탄생했다는 점이다.

이제부터 블록 체인이 어떻게 비트코인이라는 화폐의 바탕이 되는 체계가 될 수 있는지 알아보자. 먼저 화폐가 무엇인지 짧게 되새겨 보자.

## 화폐는 믿음이다

현대 사회에서 화폐란 무엇일까? 너무 모호한 것 같으니 질문을 바꿔보자. 현대 사회에서 화폐의 '실체'란 무엇일까? 과거에는 금이나 은 등 실제 실물이 화폐의 역할을 담당했지만, 점차 그 실물에 대한 교환 증서가 화폐의 역할을 담당하게 되었고, 1971년의 닉슨 쇼크 이후에는 사실상 그 실물(금)에 대한 교환도 보장해 주지 않는 불태환 화폐가 되었고, 2008년 금융 위기 이후에는 양적 완화라는 미명 하에 막대한 양의 화폐를 찍어내기도 했다. 그럼에도 불구하고 여전히 우리는 그 화폐를 가지고 큰 문제 없이 살아가고 있다. 어째서 이런 일이 가능할까?

>화폐는 '믿음'이다.

그렇다. 사실 우리는 화폐를 믿고 있다. **화폐의 실체는 바로 믿음**이다. 금으로 교환해준다는 보장은 사라졌지만, 화폐로 여전히 치킨을 먹고 맥주를 마실 수 있다고 모두가 믿고 있다. 화폐는 모두의 '신뢰'를 받고 있는 것이다. 비트코인이 가상 화폐, 디지털 화폐 또는 암호화 화폐처럼 화폐라는 용어를 달고 있는 이유도 '신뢰'할 만한 대상이 될 수 있기 때문이다. 그 **신뢰의 원천이 바로 블록 체인**이다.

그럼 블록 체인이 어떻게 신뢰의 원천이 될 수 있는지 차례차례 알아보자.

## 분산 공개 장부

A가 B에게 만원을 보내는 상황을 생각해보자. A가 은행 사이트에 접속해서 로그인하고, 잔액을 확인하고, B의 계좌 정보를 입력한 후에, 공인인증서나 OTP 등의 비밀번호를 입력하고 확인 버튼을 누르면, A의 잔액에서 만원이 차감되고, B의 잔액에 만원이 더해진다. 개인의 재산이 오가는 이 송금 과정은 매우 중요하다. 그래서 송금 거래에 필요한 모든 확인 과정은 은행에서 수행되며, 그 기록도 은행에 저장되고 외부로는 공개되지 않는다. 그래서 송금에 대해 우리가 믿는 곳은 은행 하나다. 송금 과정에 있어서의 모든 것이 은행 하나에 집중되어 있다. 이는 바꿔 말하면 **은행이 바로 단일 실패 지점**(Single Point of Failure)이라는 말이다. 즉, 거래 은행의 서버가 정상적으로 동작하지 않거나, 은행의 기록이 사라지게 되면 우리는 재산을 잃게 된다.

소프트웨어 시스템 분야에서 이런 단일 실패 지점 문제를 해결하는 보편적인 방법은 고가용성 처리, 쉽게 말해 다중화다. 2중, 3중으로 복제나 분산처리를 해서 단일 실패 지점을 없애는 전략을 취한다. 은행 시스템도 이런 다중화 처리가 되어 있으므로 앞에서 말한 어처구니 없는 불상사는 쉽게 일어나지 않는다. 소프트웨어 뿐 아니라 보안 담당 직원 배치, 보안 담당 장비 도입 등으로 더 한층 위험을 낮춘다. 하지만 이런 조치를 위해서는 많은 비용이 필요하다. 

블록 체인은 이 문제를 완전히 다른 각도에서 바라본다(각주: 설명의 단순화를 위해 이후로 퍼블릭 블록 체인만을 대상으로 한다). 즉, 거래 정보를 감추지 않고 모두에게 공개하고, 누구나 거래 정보를 생성할 수 있으며, 거래 정보를 모두에게 복사해서 사본을 저장하고 그 사본끼리 동기화시킨다. 쉽게 말해 **2중화, 3중화 정도가 아니라 수천중화, 수만중화 처리를 해서 기록이 사라지는 일을 원천적으로 막아버린다**. 그래서 블록 체인을 거대한 분산 공개 장부라고 부르기도 한다.

>블록 체인은 거대한 분산 공개 장부다.

이렇게 수천 수만의 분산 처리를 통해 기록의 멸실은 막을 수 있지만, 이것만으로는 멸실만큼이나 위험한 기록의 위/변조까지 막을 수는 없다. 블록 체인은 이 문제를 암호학의 도움을 받아서 해결한다.

## 디지털 서명

개발자라면 디지털 서명에 대해 희미하게라도 알고 있겠지만, 블록 체인을 얘기할 때 빼놓을 수 없는 중요한 부분이므로 다시 한 번 짚고 넘어가자.

디지털 서명은 비대칭키와 해쉬 함수를 이용해서 다음과 같은 방식으로 데이터의 진위 여부를 확인할 수 있게 해준다.

%%% 디지털 서명 그림 %%%

**블록 체인에 담겨 있는 모든 거래 정보에는 이렇게 디지털 서명이 포함**되어 있어서 **거래 정보가 진본임을 신뢰**할 수 있다.

## 블록이란?

자 이제부터 진짜 블록 체인의 내부로 들어가볼 차례다. 앞으로 나올 구체적인 내용은 블록 체인의 최초 구현체인 비트코인에서 구현된 내용이며, 구현체마다 방식이 다를 수도 있다. 블록 체인이라는 체인을 이루는 원소인 블록은 무엇일까?

>블록은 유효한 거래 정보의 묶음이다.

"A가 B에게 100원을 송금한다."와 같은 것이 하나의 거래이며, **하나의 블록에는 여러 개의 거래가 포함**된다. 비트코인을 예로 들어 들면 하나의 블록에는 평균 약 1,800개의 거래 정보가 포함될 수 있으며, 블록의 물리적인 크기는 평균 0.98Mbyte이다(출처: https://blockchain.info/charts). 블록은 블록 헤더와 거래 정보, 기타 정보로 구성된다.

- 블록 헤더는 `version`, `previousblockhash`, `merklehash`, `time`, `bits`, `nonce` 이렇게 6개의 정보로 구성된다.
- 거래 정보는 입출금과 관련한 여러가지 정보를 가지고 있다.
- 기타 정보는 블록 내에 있는 정보 중에서 블록 헤더와 거래 정보에 해당하지 않는 정보를 말하며, 블록 해쉬 계산에 사용되지 않는다.

이 중에서 블록 체인의 메커니즘을 이해하는 데 중요한 열쇠가 되는 정보는 **블록 헤더**다.

### 블록 헤더

블록 헤더는 다음의 6가지 정보로 구성된다.

1. version : 소프트웨어/프로토콜 버전
2. previousblockhash : 블록 체인에서 바로 앞에 위치하는 블록의 블록 해쉬
3. merklehash : 개별 거래 정보의 거래 해쉬를 2진 트리 형태로 구성할 때, 트리 루트에 위치하는 해쉬값
4. time : 블록이 생성된 시간
5. bits : 난이도 조절용 수치
6. nonce : 최초 0에서 시작하여 조건을 만족하는 해쉬값을 찾아낼때까지의 1씩 증가하는 계산 회수

블록 헤더가 중요한 이유는 **블록의 식별자 역할을 하는 블록 해쉬가 이 블록 헤더의 6가지 정보를 입력값으로 해서 구해지기 때문**이다.

### 블록 해쉬

블록의 식별자 역할을 하는 블록 해쉬는 6가지의 블록 헤더 정보를 입력값으로 하고, 여기에 SHA256 해쉬 함수를 적용해서 계산되는 값으로, 32바이트의 숫자값이다. **이름은 블록 해쉬이지만 그 값은 블록 전체를 해쉬한 값이 아니라, 블록 헤더를 해쉬한 값**이다.

지금까지의 내용을 바탕으로 블록 해쉬를 구하는 과정을 그림으로 나타내면 다음과 같다.

![Imgur](http://i.imgur.com/KFtqafZ.png)

개별 거래 정보는 결국 머클 트리의 해쉬값인 `merklehash` 값으로 집약된다. 블록 헤더의 6가지 정보 중에서 `version`, `previousblockhash`, `merklehash`, `time`, `bits` 이렇게 5가지는 블록 해쉬를 만드는 시점에서 이미 확정되어 변하지 않는 값이다. 하지만 마지막 `nonce`는 확정되어 있지 않고 새로 구해야 하는 값이다. **이 `nonce` 값을 구해서 최종적으로 블록 해쉬 값을 구하고, 이 블록 해쉬값을 식별자로 가지는 유효한 블록을 만들어내는 것이 바로 작업 증명(Proof of Work), 흔히 말하는 채굴**이다.

작업 증명에 대해 알아보기 전에, 이제 블록이 무엇인지 알게 되었으니 블록이 이어져서 만들어지는 블록 체인을 기술적으로 다시 살펴 보자.

## 블록 체인이란?

블록 체인은 앞에서는 거대한 분산 공개 장부라고 했는데, 기술적으로는 **블록이 이어져서 만들어진 블록의 집합체**라고 말할 수 있다.

블록들은 어떻게 이어져 있는걸까? 앞에서 살펴본 블록 헤더의 6가지 정보 중의 하나인 `previousblockhash` 값은 현재 생성하고 있는 블록 바로 이전에 만들어진 블록의 블록 해쉬값이다. 블록은 바로 앞의 블록 해쉬 값을 포함하는 방식으로 앞의 블록과 이어지게 된다. 

![Imgur](http://i.imgur.com/IHS979r.png)

어디서 많이 본 구조 아닌가? 그렇다. **블록 체인은 사실 링크드 리스트**다.

>블록 체인은 블록으로 이루어진 링크드 리스트다.

블록 체인을 자료 구조 측면에서도 살펴봤으니 이제 좀더 내부로 들어가보자.

## 블록 체인의 첫번째 핵심 - 작업 증명

이제 블록과 블록 체인에 대해 일반인보다는 아주 조금 더 깊게 이야기할 수 있게 되었다. 하지만 기술적인 관점에서는 이제 첫걸음을 내디딘 것에 불과하다. 좀더 핵심으로 들어가보자. 첫번째 핵심은 작업 증명(Proof of Work)이다.

앞에서 `nonce`값을 구해서 최종적으로 블록 해쉬값을 구하고, 이 블록 해쉬값을 식별자로 가지는 유효한 블록을 만들어내는 것이 작업 증명이라고 했다. 결국 `nonce` 값을 구하는 것이 작업 증명의 핵심이다. `nonce`값을 구하는 방법을 알아보기 전에 먼저 `nonce`값이란 어떤 값을 의미하는 지 알아야 한다.

>`nonce`값은, 이 `nonce`값을 입력값 중의 하나로 해서 계산되는 블록 해쉬값이 특정 숫자보다 작아지게 하는 값을 말한다.

그럼 이 `nonce`값은 어떻게 구할 수 있을까? 위의 설명에서 맨 마지막 부분을 떼어보면 **해쉬값이 특정 숫자보다 작아지게 하는 값**이라고 한다. 해쉬 함수의 특성상, 어떤 해쉬값(A라고 하면)을 결과로 나오게 하는 입력값을 찾으려면, A에서 역산을 하는 방식으로는 찾을 수 없고, 결과가 A가 될 때까지 무작위로 입력값을 계속 바꿔가면서 해쉬값을 계산해보면서 찾아낼 수 밖에 없다. 

그렇다면 어떤 블록 해쉬값이 어떤 특정 숫자보다 작아지게 하려면, 블록 해쉬의 입력값을 계속 바꿔가면서 구한 해쉬값이 특정 숫자보다 낮은지 비교하는 작업을 계속 반복하는 수 밖에 없다. 블록 해쉬의 입력값은 블록 헤더고, 블록 헤더에는 6가지 정보가 담겨 있으며, 이 중에서 5가지는 값이 고정되어 변경할 수 없고, 오직 `nonce`만 값을 바꿀 수 있다. 즉, 이 `nonce`값을 계속 바꿔가면서 계산한 해쉬값이 어떤 특정 숫자보다 작다면, 그 때의 `nonce`값이 `nonce`값으로 확정되고, 특정 숫자 보다 작게 나온 그 해쉬값이 그 블록의 블록 해쉬값으로 최종 확정되며 작업 증명이 끝나게 된다. 이 과정을 그림과 함께 살펴보자.

![Imgur](http://i.imgur.com/caPbxeH.png)

앞에서 설명한 대로 `nonce` 외의 모든 항목의 값은 이미 정해져 있다.

`nonce` 값이 0 일 때의 해쉬를 구해보니 `000000a84...`보다 큰 `fa8cbaeed...` 가 나와서 작업 증명에 실패 했다.

다시 `nonce`가 1 일 때의 해쉬를 구해보니 `932d16e2e...` 가 나와서 또 실패.. `nonce`가 2 일 때의 해쉬, 3 일 때의 해쉬.. 를 계속 반복해서 구하고 실패하다가, `nonce`가 82,764,351 일 때의 해쉬를 구해보니 드디어 `000000a84...` 보다 작은 `000000a83...`이 나와서 작업 증명에 성공했다.

그렇다면 작업 증명 성공 여부의 기준이 되는  `000000a84...`라는 값은 어떻게 정해지나? 그 값은 작업 난이도에 의해 결정되는데 이 부분은 핵심은 아니므로 그보다 더 중요한 보상에 대해 알아보자.

### 보상

이렇게 `nonce` 값을 구하는 채굴 작업에는 엄청나게 많은 횟수의 해쉬 계산이 필요하며 그런 계산을 수행하는 채굴기와 그 채굴기를 돌릴 수 있는 막대한 양의 전기라는 비용이 든다. 그래서 이런 비용에 대한 보상이 없다면 아무도 채굴을 하지 않을 것이다. 비트코인에서의 **보상은 새로 발행되는 비트코인과 해당 블록에 포함되는 거래의 거래 수수료의 합**이다. 비트코인의 새로운 발행은, 채굴자가 블록을 처음 구성할 때 채굴자의 지갑으로 일정량의 비트코인이 입금되는 거래를 그 블록의 첫 거래(generation transaction)로 추가하는 방식으로 이루어진다. 

![Imgur](http://i.imgur.com/djOnK4M.png)

새로 발행되는 비트코인은 최초에 50BTC에서 시작해서 블록 체인에 21만개의 블록이 추가될 때마다 절반으로 줄어들어 2017년 7월 현재는 블록 당 12.5BTC가 새로 발행되며, 보상의 일부로서 채굴자에게 주어진다.

거래 수수료는 각 거래 당사자끼리 자율적으로 정할 수 있고, 거래가 블록에 추가되는 우선 순위를 결정하는데 거래 수수료가 입력값으로 사용되기도 한다.

>보상은 `nonce` 값을 찾아내고, 그 결과 새로운 블록을 블록 체인에 추가해서, 
>
>해당 블록에 포함된 모든 거래를 유효한 거래로 확정시켜준 대가라고 할 수 있다.

## 블록 체인의 두번째 핵심 - 충돌 해소

블록 체인의 첫번째 핵심은 작업 증명이며, 이는 블록 단위에서 처리되는 일이다. 블록 체인의 두번째 핵심은 **충돌 해소**인데, 이는 블록 단위가 아니라 블록 체인 단위에서 처리되는 일이다. 어떤 충돌을 의미하는 것인지 또 왜 해소시켜야 하는지 알려면 블록 체인을 분산 환경에서 바라볼 필요가 있다.

### 거래 정보의 전파

앞에서 블록 체인은 거대한 분산 공개 장부라고 했다. 이 **분산 공개 장부는 여러 개의 노드에 복사**되어 있으며, **여러 개의 노드는 p2p로 연결되어 블록 체인 네트워크를 형성**한다. 그리고 하나의 거래 정보가 발생하면 이 거래 정보는 블록 체인 네트워크에 분산되어 있는 수많은 노드에 전파되어야 한다.

하나의 거래 정보가 발생하면, **거래 정보를 받은 노드는 먼저 해당 거래의 유효성을 검증한 후에 그 거래를 아직 블록 생성 작업이 시작되지 않은 후보 블록에 추가하고, 인접한 다른 노드에 그 거래 정보를 전파**한다. 거래 정보의 전파를 그림으로 나타내면 다음과 같다.

![Imgur](http://i.imgur.com/C61jZWH.png)

### 블록의 생성 및 전파

블록에 거래 정보가 채워지면 노드는 블록을 생성한다. 이때 캐나다에 있던 노드와 호주에 있던 노드는 상당히 멀리 떨어져 있으므로, 각 블록에 담겨 있는 거래의 내용과 순서는 다음과 같이 서로 다를 수 있다.

![Imgur](http://i.imgur.com/AraOlPF.png)

새로 만들어질 블록은 다음 그림(출처: Mastering Bitcoin - http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks)과 같이 현재 마지막 블록인 파란색 P블록의 다음에 추가될 예정이다.

![출처: http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0802.png)

이 때 캐나다의 노드와 호주의 노드가 거의 동시에 `nonce` 값을 찾아서 블록을 성공적으로 생성했다. 캐나다의 노드가 생성한 블록을 A블록(빨간색)이라 하고, 호주의 노드가 생성한 블록을 B블록(녹색)이라하면, 생성 후 전파 과정은 다음 그림(출처: Mastering Bitcoin - http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks)과 같다.

![http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0804.png)

캐나다 노드의 인접 노드에서는 전달받은 A블록의 블록 해쉬를 다시 계산해서 그 값이 정말로 특정한 숫자보다 작은 올바른 값인지 검증한 후에, 자신이 가지고 있던 P블록에 A블록을 추가한다. 호주 노드에 인접한 노드에서도 마찬가지 방식으로 기존의 P노드에 B노드가 추가된다. 이 방식이 계속되면서 A블록과 B블록은 전 세계에 분산되어 있는 노드에 전파된다.

### 블록 체인의 분기

포르투갈에 있는 노드에는 A블록이 먼저 전파된 후에 B블록이 전파파되었다. 포르투갈 노드에서는 늦게 도착한 B블록은 무시된다. 러시아에 있는 노드도 나름 열심히 `nonce` 값을 구하고 있었으나, 구하기 전에 아쉽게도 B블록을 먼저 전달받아서 B블록을 검증한 후 P블록 다음에 B블록을 추가했다. B블록에 이을 새로운 블록의 `nonce`값을 구하기 시작하고, 잠시 후 A블록을 전달받았다. 늦게 도착한 A블록은 러시아 노드에서는 무시된다. 이번에는 러시아 노드가 가장 먼저 `nonce` 값을 구해서 B블록 다음에 새로 X블록(핑크색)을 생성해서 B블록 다음에 X블록을 추가하고 다음 그림(출처: Mastering Bitcoin - http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks)과 같이 인접 노드에 전파했다. 

![http://chimera.labs.oreilly.com/books/1234000001802/ch08.html#forks](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0805.png)

포르투갈에 있던 노드에는 P블록 다음에 A블록이 추가되어 있는 상태였는데, P블록, B블록에 이어진 새로운 X블록을 전달받았다. 포르투갈에 있던 노드에는 다음과 같이 블록 체인의 분기가 발생한다.

![Imgur](http://i.imgur.com/GOSBL5l.png)

A블록과 B블록의 내용은 서로 다르다. 블록 체인은 신뢰의 원천이 되는 체계라고 했는데, 이렇게 정보가 갈라지는 체계를 믿을 수 있는걸까?

### 어느 블록 체인을 믿을 것인가?

블록 체인에서는 이렇게 분기가 발생해서 충돌이 일어날 때 어느 블록 체인을 믿을 것인가에 대한 기준이 마련되어 있다. 그렇지 않으면 분산되어 있는 장부 내용의 동기화가 깨지기 때문이다. 그 기준은 다음과 같다. 

>블록 체인에 분기가 발생하여 충돌하게 될 때는 길이가 더 긴 블록 체인을, 다시 말하면, 더 많은 작업 증명이 수행된 블록 체인을 선택한다.

그래서 포르투갈의 A블록은 더 긴 블록 체인을 가진 X블록이 전파되는 순간 P블록에서의 연결이 끊어지고 고아가 된다. **블록 생성은 평균 10분이 소요될 정도로 연산량이 큰 작업이며, 따라서 앞에서 발생한 것처럼 A블록과 B블록이 거의 동시에 생성되어 분기가 발생할 가능성은 그리 높지 않다**. 그리고 **길이가 같은 블록 체인이 충돌하더라도 머지 않아 블록 체인의 길이가 달라지져서 분기에 의한 충돌이 해소되는 순간이 금방 다가온다**. 다음 그림은 길이가 긴 블록 체인에 의해 고아가 되는 블록의 수를 나타내는데, 최근 1년간 대부분 2개 이하, 최대 3개 이내에서 블록 체인의 분기에 의한 충돌이 해소됨을 알 수 있다.

![Imgur](http://i.imgur.com/9KGZ5oK.png)

하지만 일시적으로나마 이런 분기 상태가 발생할 수 있기 때문에, 실제 거래 상황에서는 보통 어떤 거래가 포함된 블록 이후로 3-5개의 블록이 더 추가된 후에야 그 거래를 최종적으로 유효한 것으로 확정한다. 일시적으로 분기가 발생하더라도 그 이후로 3-5개의 블록이 추가되는 과정에서 분기 상태가 해소되고 결국 하나의 블록 체인만 남기 때문이다.

### 고아가 된 A블록에 있던 거래 중 유실되는 거래가 생기지 않을까?

A블록에 있던 거래 중에서 B블록에 포함되지 않았던 거래T가 있을 수 있다. 그럼 A블록이 고아가 되면 거래T는 결국 유실되는 것이 아닐까하는 의문이 들 수 있다. 하지만 **유실은 발생하지 않는다**. 거래T는 B블록에는 포함되지 않았더라도 X블록 또는 X블록 이후의 블록에 결국에는 포함되게 된다. 왜냐하면, X블록은 B블록을 부모로 해서 생성되는데 거래T가 B블록에 포함되지 않았으므로, B블록에 이어 생성되는 X블록 또는 X블록 이후의 블록에서는 거래T를 아직 블록 체인에 포함되지 않은 다른 거래들과 마찬가지로 취급하며 블록에 추가하기 떄문이다.

## 블록 체인의 세번째 핵심 - 완료된 거래 정보의 변경 불가

거래 정보의 해쉬값은 해당 거래가 포함된 블록의 `merklehash` 계산에 입력값으로 사용되고, `merklehash`는 블록 해쉬의 계산에 입력값으로 사용된다. 블록 해쉬는 다음 블록(M이라 하면)의 `previousblockhash` 값으로 저장되며, `previousblockhash`은 M블록의 블록 헤더 정보로서, M블록의 블록 해쉬를 계산하는데 입력값으로 사용된다.

따라서, 어떤 거래 정보가 변경되면 그 거래 정보가 포함된 머클트리의 `merklehash`가 변경되고, `merklehash`가 변경되면 블록 해쉬가 변경되고, 블록 해쉬의 변경은 다음 블록의 블록 해쉬 변경으로 연쇄적으로 이어지게 된다. 그리고 블록 해쉬는 작업 증명의 해답(`nonce` 값)을 찾아내야 구할 수 있으므로, 거래 정보를 변경한 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해야 한다.

블록 하나 채굴하는데 평균 10분이 소요되므로 어떤 악의적인 노드가 바로 앞의 블록의 거래 정보를 변경하고 채굴하는 그 10분 동안, 다른 선의의 노드들은 거래 정보가 변경되지 않은 원래의 블록체인에 계속 블록을 이어 나가게 된다. 그래서 그 10분 후에는 악의적인 노드의 블록 체인의 길이는 다른 선의의 노드들이 보유한 블록 체인의 길이보다 1개 더 짧아지게 되고, 두 블록 체인이 만나게 되는 순간 길이가 짧은 블록 체인은 버려지게 된다.

>완료된 거래 정보를 변경하려면,
>
>변경하려는 거래 정보가 포함된 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해서 새로운 블록 체인(A)를 만들어야 하는데,
>
>그동안에도 변경 되지 않은 원래의 블록 체인에는 다른 노드들에 의해 블록이 계속 추가되고 A보다 길이가 길어지게 되므로,
>
>A는 폐기되며 완료된 거래 정보의 변경은 실패하게 된다.

그런데 악의적인 노드가 다른 노드들보다 연산 능력이 훨씬 뛰어나다고 가정해보자. 그렇다면 악의적인 노드에 있는 블록 체인에 블록이 추가되는 속도가 다른 블록 체인에 블록이 추가되는 속도보다 더 빠를 것이고, 언젠가는 악의적인 노드의 블록 체인의 길이가 가장 길어지게 된다. 이렇게 되는 순간 악의적인 노드에 의해 변경된 거래 정보가 유효한 거래 정보로서 전체 블록 체인 네트워크에 퍼지게 되며 과거 거래 정보의 변경이 성공하게 된다.

하지만 경제적인 관점에서 생각해보면 이런 일이 발생할 가능성은 사실상 없다. 일단, 거래 정보가 변경될 수 있다는 사실이 알려지는 순간 블록 체인의 신뢰는 깨지게 된다. **만약 악의적인 노드가 오랫동안 가장 큰 연산 능력을 가지고 있었다면, 악의적인 노드가 생성한 블록이 많을 것이고 그에 따른 보상액도 많이 보유하고 있을 것이다. 이런 상황에서 블록 체인의 신뢰가 붕괴되면 큰 피해를 보는 쪽은 악의적인 노드 자신**이기 떄문에 거래 정보를 변경할 경제적 동기가 없다. **악의적인 노드가 갑자기 많은 연산 능력을 가지게 되었다고 해도, 블록 체인의 신뢰 붕괴로 가치가 사라진 블록을 채굴해봤자 가져갈 수 있는 경제적 이익은 없다**. 따라서, **경제적으로 이익을 볼 수 없는 거래 정보의 변경은 사실상 발생하지 않게 된다**.


## 마무리

지금까지 블록 체인이 어떻게 비트 코인이라는 암호화 화폐의 신뢰의 원천이 될 수 있는가라는 물음에 대한 답을 찾아봤다. 정리해보면 다음과 같다.

>블록 체인은 
>
>- 거대한 분산 공개 장부이며, 그 장부 안에 포함된 개별 거래는 모두 디지털 서명이 붙어 있어서 은행이나 다른 제3자의 개입이 없어도 진본임을 보증할 수 있다.
>- 수천, 수만노드에 분산 되어 있어서 어느 한 지점에 장애나 공격이 발생하더라도 블록 체인이라는 네트워크 전체는 문제 없이 계속 돌아갈 수 있다.
>- 작업 증명이라는 수학적 계산 작업과 경제 관점에서의 논리를 통해 위/변조가 사실상 불가능한 구조를 갖게 되어, 그 안에 기록된 거래들은 은행같은 중앙의 보증 기관이 없이도 신뢰할 수 있는 거래로서 확정될 수 있다.

블록 체인에도 여러 가지 도전적인 과제들이 있고, 그중에서 가장 중요한 것은 블록 체인의 확장성 문제다. 여기에서 그런 내용을 모두 다룰 수는 없겠지만, 지금까지 펼쳐놓은 이야기가 앞으로 블록 체인에 대한 자료를 접할 때 이해의 폭을 넓혀줄 수 있는 발판을 제공해 줄 수 있기를 바란다.

블록 체인은 거래 당사자간의 신뢰 확보를 위해 중앙 기관을 필요로 하지 않는 탈중앙화(Decentralization)를 달성한 최초의 소프트웨어 기술이다. 비트코인은 화폐에 한정되어 있지만 이더리움이나 최근 개발되고 있는 EOS나 IOTA, 국내에서 개발되는 BlockchainOS 등은 단순한 화폐를 넘어서 블록 체인 위에서 당사자간의 계약을 프로그램으로 실행시킬 수 있는 탈중앙화 플랫폼을 지향하고 있다. **블록 체인이 세상을 바꿀 수 있는 기술이라고 평가받는 이유도 이처럼 탈중앙화 플랫폼의 바탕이 되기 때문**이다. 좀더 나은 세상을 만드는데 기여할 수 있는 좋은 기회의 문이 열리고 있다.





## FAQ로 정리해보는 블록 체인

### 블록을 생성하는데 성공한 단 한 명의 채굴자만 보상을 받는건가?

그렇다. 그래서 이론적으로는 평생 채굴기를 돌려도 단 하나의 블록도 생성하지 못할 수도 있다. 그래서 실제로는 채굴 풀(pool)을 형성해서 `nonce` 값을 찾는 계산 작업을 분담하고, 해당 풀에서 블록이 생성되면 풀에 참가한 채굴자들끼리 각자의 배분 기준에 의해 보상액을 배분 받는 방식으로 채굴 시장이 운영된다.

### 작업 난이도는 무엇인가?

블록 해쉬가 특정 숫자보다 낮게 나올 때의 `nonce` 값을 찾아내는 것이 작업 증명이라고 했다. **작업 난이도는 `nonce` 값 계산의 어려운 정도**를 나타낸다. 작업 난이도는 블록 헤더 정보에서 `bits`라는 값으로 조절된다.

앞에서 블록 해쉬는 32바이트의 숫자라고 했는데, 이해를 쉽게 하기 위해 블록 해쉬를 부호 없는 1바이트의 숫자라고 해보자. 그럼 1바이트의 숫자값을 블록 해쉬값으로 산출하는 해쉬 함수는 0 ~ 255 사이의 값을 결과로 산출한다.

블록 해쉬가 128보다 작아야 한다고 하면, 0 ~ 255 사이의 값을 산출하는 해쉬 함수를 적용해서 128보다 작은 블록 해쉬값이 나올 확률은 `128보다 작은 수(0~127)의 개수 = 128`/`해쉬 함수가 산출할 수 있는 모든 값(0~255)의 개수 = 256`, 즉, `128/256`이므로, 50%의 확률이다.

블록 해쉬가 64보다 작아야 한다면 64/256, 즉 25%의 확률로 `nonce` 값을 구할 수 있다. 블록 해쉬가 32보다 작아야 한다면 확률은 12.5%로 줄어든다. 여기서 128, 64, 32라는 특정 숫자가 바로 블록 헤더 정보의 `bits`이다.

실제로 `bits`의 값이 128, 256 이런 식으로 저장되지는 않고, 지수와 계수를 사용하는 별도의 표현 방식이 있다.

난이도는 2,160개의 블록이 생성되는데 소요되는 시간이 평균 시간인 21,600분(10분/블록 \* 2,160블록)보다 오래 걸리면 낮아지고, 적게 걸리면 높아지는 방식으로, 대략 21,600분을 주기로 전체적으로 평균 10분이 소요되는 하나의 난이도가 전체에 적용된다. 따라서 채굴자가 늘어나서 블록을 생성하는데 소요되는 시간이 줄어들게 되면, 정해진 주기에 따라 난이도가 높아져서 결국에는 평균적으로 10분이 소요되게 된다.

>블록 헤더의 `bits`는 `nonce` 값을 계산하는데 기준이 되는 특정 숫자를 나타내며,
>
>블록체인 전체에 걸쳐 일률적으로 적용되는 숫자다.

### 비트코인 지갑에도 블록 체인의 모든 거래 정보가 저장되나?

비트코인 지갑은 송수금 거래를 가능하게 해주는 클라이언트 소프트웨어이며, 거래 정보를 블록 체인 네트워크에 전파해야 하므로 블록 체인 네트워크의 노드이기도 하다. 하지만, 지갑은 작업 증명 계산을 하지 않기 때문에 블록 체인의 모든 거래 정보를 저장할 필요가 없고, 저장하지도 않는다. 블록 체인 네트워크에 참여하는 노드는 여러 종류가 있으며, 지갑에는 블록 체인의 전체 거래 정보가 저장되지는 않는다.

### 채굴 보상이 줄어든다면 채굴에 의해 유지되는 블록 체인이 지속될 수 있나?

비트코인을 예로 들면 채굴 보상은 비트코인으로 지급되며, 지급되는 양은 비트코인 기준으로는 줄어들지만 비트코인 자체의 가치가 늘어난다면 보상 자체가 줄어드는 것은 아니다. 몇 년전에 채굴 보상이 50BTC 이고 현재 보상이 12.5BTC로 1/4로 줄었다고 하더라도, 비트코인 자체의 가치는 4배가 훨씬 넘게 증가했기 때문에 실질 보상액은 오히려 늘어났다고 볼 수 있다. 이처럼 디플레이션 화폐라는 비트코인의 특징은 비트코인의 가격을 높이는 중요한 요인이기도 하다. 하지만 신규 발행 비트코인이 0이 되는 시점(약 2100년 이후)에서 어떤 모습일지는 상상하기 어렵지만, 아마도 난이도를 낮추는 방식으로 전개될 가능성이 높다. 남는 채굴 보상은 수수료 뿐이고 수수료를 높게 가져가면 비트코인의 이용률이 떨어지게 되기 때문이다. 
